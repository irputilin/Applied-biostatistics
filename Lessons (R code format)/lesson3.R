#############################################################
#                                                           #
#                      Типы данных в R                      #
#                       (продолжение)                       #
#                                                           #
#############################################################

# Освежим в своей памяти (и в памяти R) переменные, представленные ниже.
# Они понадобятся чуть позже

gender <- c('male', 'male',
            'female', 'female',
            'male', 'female',
            'male')

x <- c(170, 180, 172, 163, 192, 201, 177)
w <- c(78, 83, 62, 66, 91, 55, 66)

# При взгляде на переменную gender понимаем, что она, по всей видимости,
# категориальная. Соответственно, нужно перевести её в факторную с 
# помощью функции as.factor()

gender <- as.factor(gender)

# Продолжая разговор про категориальные данные стоит вспомнить, что,
# обычно, между разными уровнями фактора нет как таковой ирерархической
# зависимости. Однако, может произойти такая ситуация (и на дальнейших
# лабораторных она непременно произойдёт) что иерархические взаимоотношения
# между уровнями фактора нужно будет задать. В этом нам поможет функция
# ordered()
#
# Для начала создадим новую переменную m, в которую запишем размеры
# одежды


m <- as.factor(c('L','S','XL','XXL','S', 'M', 'L')) # сразу же делаем
                                                    # её факторной


# R в этой переменной видит лишь факторный вектор и ему не понятно,
# что, вообще-то это размеры одежды и мы, люди, точно знаем, что
# S меньше M, M меньше L, L меньше XL и т.д. Соответственно, мы можем
# подобную структуру сообщить

m <- ordered(m ,levels=c('S','M','L','XL','XXL')) # указываем уровни
                                                  # фактора в таком порядке
                                                  # в котором необходимо

# Взглянув на эту упорядоченную переменную с помощью функции str() видим,
# что теперь уровни фактора как-то друг от друга зависят, что отражает
# реальную картину


#### Логические данные #### 

# С логическимы данными мы уже с вами встречались на этапах, когда
# проверяли: является ли какая-либо переменная векторной, факторной, 
# числовой и т.д. Логических переменных существует всего две - TRUE и 
# FALSE. Они полезны в автоматизации, а также зачастую используются 
# для задания параметров многих функций. 
# 
# Эти переменные могут выглядет либо явным образом (TRUE и FALSE),
# либо в сокращённом виде - T и F
#
# Создадим факторную переменную l


l <- c(TRUE, FALSE, T, F, T, F, T)

# Т.к. любая переменная в R является вектором, соответственно 
# над логическим вектором мы можем совершать любые арифметические 
# операции

l * 100

# Получившийся результат не должен вас удивлять, потому что 
# с логическим TRUE соотносится число 1, а с логическим FALSE - 0
# Просто попробуйте перевести переменную l в числовую и посмотрите
# на результат

#### Пропущенные данные ####

# Очень даже не редка ситуация, когда в данных отсутствуют какие-то 
# значения. Да, в R это отдельный тип данных - пропущенные данные.
# Довольно важно уметь справляться с ситуацией, когда они появляются,
# потому что часть функционала, необходимого для статистического
# анализа попросту не будет работать из-за пропусков ввиду 
# вычислительных ограничений
# 
# Для понимания, как это выглядит сделаем 3й элемент переменной x
# пропущенным

x[3] <- NA
x

# Для того, чтобы понять, каким образом функции не работают с 
# пропущенными данными, запустим следующую строку:

mean(x)

# Результат выполнения функции - пропущенное значение!
# В случае с функцией mean() обойти этот момент довольно просто,
# добавив параметр na.rm

mean(x, na.rm = T)

# Существует два способа избежать пропущенные данные.
# 1 - просто их удалить. 
# Вполне неплохое решение, особенно если потеряется несущественное 
# количество данных

na.omit(x) # Данная функция прекрасно работает и для таблиц
           # удаляя строки с пропущенными данными

# 2 способ - заменить другими. Зачастую, используют замену средними 
# значениями. Конечно, если мы говорим, что пропущенных данных
# буквально половина из всех - такой способ вряд ли даст нам что-то
# положительное для дальнейшего анализа. Однако, в случае большой 
# выборки данных добавленное одно-два добавленных средних значения
# существенно не изменят распределение данных
# (чуть позже начнём разбираться с тем, что за странные слова я 
# тут написал)

# В квадратных скобочках можно использовать не только индексы и 
# операторы, но и вполне себе любые функции. Стоит понимать, что
# в таком случае мы будем обращаться к тем элементам вектора,
# результат выполнения заданной функции по которым будет логическим,
# а именно TRUE. В подобном обращении все FALSE'ы будут пропускаться

# Заменим пропущенное значение средним по исходному вектору

x[is.na(x)] <- mean(x, na.rm = T)
x


#### Логические операторы #####

# Прежде чем обратиться к логическим операторам - есть смысл разобрать
# индексацию векторов. 
# Не стоит пугаться данного словосочетания. На самом деле имеется ввиду
# обращение к конкретным элементам векторов используя их порядковые
# номера - индексы. Обращения к элементам векторов производятся с помощью
# квадратных скобочек

x[3]                   # Извлечь 3 элемент
x[2:6]                 # Извлечь элементы со 2 по 6

# Помимо использования конкретных индексов внутри квадратных скобочек
# можно пользоваться любыми арифметическими и логическими операторами

x[x > 170]             # Извлечь все элементы больше 170
x[x < 170]             # Извлечь все элементы меньше 170
x[x == 170]            # Извлечь все элементы равные 170
x[x >= 170]            # Извлечь все элементы, которые больше или равны 170
x[x <= 170]            # Извлечь все элементы, которые меньше или равны 170
x[x != 170]            # Извлечь все элементы неравные 170

# Можно проверить сам факт наличия конкретной переменной в векторе

170 %in% x 

# В дальнейшейм, эта конструкция будет использоваться для проверки
# наличия векторов в матрица, конкретных данных в таблицах и много
# где ещё. В общем - полезно знать заранее

# Логические операторы довольно просты в использовании и не сложны в 
# запоминании
#     
#     & - И
#     | - ИЛИ
#     ! - НЕ


x[x > 170 & x < 190]   
x[x > 170 | !(x < 190)]

# Помимо того, что логические операции можно использовать для отдельных
# векторов, их можно использовать и для нескольких. Концептуально, это
# похоже на работу с таблицами, где каждый вектор - это столбец, а каждый
# отдельный элемент вектора представляет строку

((x < 180) | !(w <= 70)) & (gender =='female' | m == 'S')


#### Условная конструкция if / else ####

# Логические операторы, разобранные ранее являются крайне полезными 
# для того, чтобы использовать их в конструкции if / else
# В общем виде конструкция выглядит следующим образом:

if(условие){исход 1} else {исход 2} 

# В полном виде (представлено ниже) конструкция используется для
# конкретных элементов вектора, однако в дальнейшем мы разберём,
# как её можно использовать для автоматизации проверки

if(gender[1] == 'female'){
  print('Это женщина')
} else {
  print('Это мужчина')
}

# Также, есть функция ifelse(), которая позволяет использовать
# условные конструкции для всех элементов вектора и получать
# на выходе вектор логических значений

ifelse(gender=='female', 'Это женщина', "Это мужчина")

#### Data frames. Табличные данные ####

# В рамках R табличные данные могут быть представлены абсолютно
# разными способами - матрицы, тибблы, вектора векторов... 
# Однако, наиболее удобным для понимания и работы представляются
# датафреймы. Если вы вспомните предыдущее домашнее задание, то
# вы уже знакомились с датафреймом "mtcars".

# Помимо того, что можно пользоваться встроенными наборами данных
# (что, безусловно, полезно в обучающих целях), можно работать со
# своими готовыми таблицами. Наиболее простой формат таблицы, 
# которые можно импортировать в R - CSV - comma separated values.
# Для того, чтобы импортировать такую таблицу в R необходимо 
# воспользоваться функцией read.csv()

df <- read.csv('babies.csv') # Этой таблицы у вас нет, поэтому,
			     # пишите названия своих таблиц и
			     # и обращайтесь к имеющимся там столбцам

# В виду того, что на разных операционных системах (и использованием
# разных языков системы) такой формат может слегка отличаться, 
# рекомендую почитать справку по этой функции (предварительно, открыв
# этот файл в блокноте, чтобы явно взглянуть на его структуру):

?read.csv  # Подсказка - обратите внимание на параметры dec и sep

# Помимо того, что у датафреймов есть строки и столбцы, у них ещё есть
# отдельные элементы - названия столбцов, и, далеко не всегда, но
# названия строк. Эти элементы являются векторами.
# Для того, чтобы обратиться к названиям столбцов нужно использовать
# функцию names(), либо colnames()

names(df)

# Так как эти названия являются векторами - над ними можно производить
# любые операции, которые можно делать с векторами и которые мы с вами
# разобрали раньше

names(df)[3] <- 'ВЕС РЕБЁНКА'
names(df)[names(df)=='case'] <- 'СЛУЧАЙ'

names(df)

# Для того, чтобы обращаться к конкретным столбцам нашей таблицы, можно
# воспользоваться либо их порядковым номером:

df[,1]     # Порядковый номер нужно указывать ПОСЛЕ запятой
df[,2]     

# Чтобы обратиться к конкретной строке также можно воспользоваться её порядковым
# номером

df[1,]     # Порядковый номер нужно указывать ДО
df[2,]

# Если вы напишите какие-то число и ДО и ПОСЛЕ запятой, то вы обратитесь к 
# конкретной ячейке, буквально указав её координаты

df[3,4]

# Помимо того, что к столбцам можно обращаться с помощью их индексов,
# удобнее использовать их названия. Делается это с помощью символа $

df$parity

# Чтобы добавить новый столбец, нужно, прежде всего, что-то в него записать
# например, вектор значений, либо результат выполнения какой-либо функции.
# А также дать ему название также используя символ $

df$STOLBEC <- 1:1236     # Столбца с таким названием у меня нет. Я буквально его добавил

df$`КУРИТ ИЛИ НЕТ` <- ifelse(df$smoke==1,'Курит',
                             'Не курит')

# Практически в 100% случаев вы работаете с таблицами в MS Excel. Как минимум, вы их там 
# формируете. Для того, чтобы импортировать их в R я, всё же, рекомендую сохранять их в формате
# csv, однако, также имеется возможно открыть непосредственно таблицу в формате .xlsx (.xls)
# Для этого вам понадобится установить библиотеку "readxl"

install.packages('readxl') # Достаточно выполнить эту строку один единственный раз
 		           # Если вы выключите компьютер и включите его заново, то
			   # установленные библиотеки никуда не потеряются!

# После установки необходимо будет эту библиотеку подгрузить в R с помощью функции library()

library(readxl)

# Чтобы открыть необходимую таблицу необходимо воспользоваться функцией из этой библиотеки - 
# read_xlsx() (или read_xls(), в зависимости от формата)

df2 <- read_xlsx('babies.xlsx')

# Также, рекомендую ознакомиться с параметрами данной функции (?read_xlsx)

На данном этапе, если в ваших таблицах имеются пропущенные данные, вы можете
либо заменить пропуски в своих столбцах, как я показывал ранее на примере
вектора x (справедливо только для столбцов с непрерывными данными)
Либо, можете воспользоваться функцией na.omit() с которой вы уже знакомы
и она удалит строки с пропущенными значениями

df <- na.omit(df)

##########################################   ДОМАШНЕЕ ЗАДАНИЕ   ################################################
#    													       #
#  0. Найти подходящую таблицу на сайте: https://vincentarelbundock.github.io/Rdatasets/datasets.html          #
#  1. Указать, какую таблицу с сайта использовали (либо скинуть вместе со скриптом)                            #
#  2. Удалить пропуски (если требуется)       								       #
#     2.1. Если пропусков слишком много, заменить их средними значениями                                       #
#  3. Добавить в таблицу факторный столбец на основе одного из числовых, нарисовать по нему столбчатый график  #
#  4. С помощью ifelse() (или if() и else()) заменить значения в столбце 				       #
#  5. Построить точечный график по двум числовым столбцам, отобразить один любую факторную переменную          #
#                                                                                                              #
################################################################################################################


## Критерии для выбора таблицы: 
1. Побольше строк (от 100 и больше)
2. Побольше столбцов (минимум 10)
3. Хотя бы половина столбцов - числовые, непрерывные
4. Хотя бы 3-4 факторных столбца
5. Столбцы с остальными типами данных - по желанию


